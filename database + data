CREATE TABLE "Users" ("username" VARCHAR(25) NOT NULL, "password" VARCHAR(25) NOT NULL, "email" VARCHAR(50) NOT NULL, "first_name" VARCHAR(30) NOT NULL, "last_name" VARCHAR(20) NOT NULL, "role" VARCHAR(6), PRIMARY KEY ("username"));

INSERT INTO APP."Users" ("username", "password", "email", "first_name", "last_name", "role") 
	VALUES ('testname', '12345678', 'test@gmail.com', 'John', 'Doe', 'Admin');
INSERT INTO APP."Users" ("username", "password", "email", "first_name", "last_name", "role") 
	VALUES ('testUser', '12345678', 'test2@gmail.com', 'McLovin', 'McLovin', 'User');
INSERT INTO APP."Users" ("username", "password", "email", "first_name", "last_name", "role") 
	VALUES ('fakeUser', '12345678', 'test3@gmail.com', 'McLovin', 'McLovin', 'User');

CREATE TABLE "DataStructures" ("ds_id" INTEGER DEFAULT AUTOINCREMENT: start 1 increment 1  NOT NULL GENERATED ALWAYS AS IDENTITY, "name" VARCHAR(25) NOT NULL, "key_aspects" VARCHAR(500), "operations" VARCHAR(100), "when_to_use" VARCHAR(200), "when_not_to" VARCHAR(200), "resource_path" VARCHAR(255), "editor_username" VARCHAR(25), PRIMARY KEY ("ds_id"));

INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Queue', 'A Queue follows the FIFO (First In, First Out) principle, where elements are added at the 	rear and removed from the front. Variations include circular queues (where the rear connects 	to the front), deques (allowing insertion and deletion from both ends), and priority queues 	(where elements are dequeued based on priority instead of order). Queues are commonly used 	in scheduling, buffering, and breadth-first search algorithms, and they can be implemented 	using arrays, linked lists, or stacks.', 'enqueue(), dequeue(), peek(), isEmpty()', 'When processing elements in order, such as scheduling, buffering, or breadth-first search', 'When frequent access or modifications to the middle elements are needed', '/resources/animations/queue.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Stack', 'A Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Elements are added (pushed) and removed (popped) only from the top of the stack. This structure is widely used in problems involving recursion, backtracking, undo operations, and expression evaluation. It can be implemented using arrays or linked lists.', 'push(), pop(), peek(), isEmpty()', 'When operations need to be reversed (e.g., function calls, undo operations)', 'When random access to elements is needed', '/resources/animations/stack.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Stack', 'A Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Elements are added (pushed) and removed (popped) only from the top of the stack. This structure is widely used in problems involving recursion, backtracking, undo operations, and expression evaluation. It can be implemented using arrays or linked lists.', 'push(), pop(), peek(), isEmpty()', 'When operations need to be reversed (e.g., function calls, undo operations)', 'When random access to elements is needed', '/resources/animations/stack.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Array List', 'An Array List is a resizable array that allows indexed access, dynamic resizing, and fast iteration. It stores elements in a contiguous memory block and automatically resizes when capacity is exceeded. Commonly used when frequent reads or indexed access is needed, it is not ideal for frequent insertions or deletions in the middle of the list.', 'add(), get(), set(), remove(), size()', 'When frequent random access and iteration is needed', 'When frequent insertions/deletions in the middle are required', '/resources/animations/array_list.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Linked List', 'A Linked List consists of nodes where each node contains data and a reference to the next (or previous) node. Variants include singly, doubly, and circular linked lists. Unlike arrays, linked lists do not require contiguous memory, making them efficient for insertions and deletions, especially when modifying the start or middle of the list.', 'insert(), delete(), traverse(), search()', 'When frequent insertions/deletions are needed at arbitrary positions', 'When fast indexed access is needed', '/resources/animations/linked_list.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Hash Map', 'A Hash Map stores key-value pairs using a hashing function to compute an index. It allows average constant-time complexity for insertions, deletions, and lookups. Collisions are managed using techniques like chaining or open addressing. While highly efficient, hash maps do not preserve order and can have unpredictable iteration sequences.', 'put(), get(), remove(), containsKey()', 'When fast access via keys is required', 'When ordering of elements is important or memory usage is constrained', '/resources/animations/hash_map.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Set', 'A Set is a collection that stores unique elements with no duplicates. Common implementations use hash tables (HashSet) or trees (TreeSet). Sets are useful for membership tests, filtering duplicates, and performing mathematical set operations like union and intersection. However, sets do not support indexed access or element ordering unless a tree-based implementation is used.', 'add(), remove(), contains(), size()', 'When storing unique elements and checking existence is a priority', 'When duplicates are needed or order matters', '/resources/animations/set.html', 'testname');
INSERT INTO APP."DataStructures" ("name", "key_aspects", "operations", "when_to_use", "when_not_to", "resource_path", "editor_username") 
	VALUES ('Binary Trees', 'Binary Trees are hierarchical data structures where each node has at most two children, known as the left and right child. Variants include Binary Search Trees (BSTs), AVL Trees, and Heaps. Binary Trees are fundamental in search algorithms, expression parsing, and hierarchical data modeling. Properly balanced binary trees offer efficient O(log n) operations.', 'insert(), delete(), traverse(), search()', 'When data needs to be stored hierarchically for fast insert/search/delete', 'When random indexed access or sequential storage is required', '/resources/animations/binary_tree.html', 'testname');

CREATE TABLE "Algorithms" ("alg_id" INTEGER DEFAULT AUTOINCREMENT: start 1 increment 1  NOT NULL GENERATED ALWAYS AS IDENTITY, "name" VARCHAR(25) NOT NULL, "description" VARCHAR(500), "b_time_complexity" VARCHAR(12), "w_time_complexity" VARCHAR(12), "is_stable" BOOLEAN, "is_in_place" BOOLEAN, "resource_path" VARCHAR(255), "editor_username" VARCHAR(25), PRIMARY KEY ("alg_id"));

INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Insertion Sort', 'Insertion Sort is a simple sorting algorithm that builds the sorted list one element at a time.     It works by picking an element and inserting it into its correct position among the previously sorted elements.     It is efficient for small or nearly sorted datasets but inefficient for large datasets.', 'O(n)', 'O(n²)', true, true, '/resources/animations/insertion_sort.html', 'testname');
INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Bubble Sort', 'Bubble Sort is a basic comparison-based sorting algorithm that repeatedly steps through the list,     compares adjacent elements, and swaps them if they are in the wrong order.     This process repeats until the list is fully sorted. While simple, it is highly inefficient for large datasets.', 'O(n)', 'O(n²)', true, true, '/resources/animations/bubble_sort.html', 'testname');
INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Selection Sort', 'Selection Sort is an in-place comparison-based algorithm that divides the list into a sorted and an unsorted part.     It repeatedly finds the smallest element from the unsorted part and swaps it with the first unsorted element.     While it has predictable performance, it is not stable and is inefficient for large datasets.', 'O(n²)', 'O(n²)', false, true, '/resources/animations/selection_sort.html', 'testname');
INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Quick Sort', 'Quick Sort is an efficient, divide-and-conquer sorting algorithm. It selects a pivot and partitions the array into elements less than and greater than the pivot, then recursively sorts the partitions. Although its worst-case time is O(n²), using good pivot strategies (like random or median-of-three) generally ensures average-case performance of O(n log n). It is in-place but not stable.', 'O(n log n)', 'O(n²)', false, true, '/resources/animations/quick_sort.html', 'testname');
INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Merge Sort', 'Merge Sort is a comparison-based, divide-and-conquer sorting algorithm that divides the array into halves, recursively sorts them, and then merges the sorted halves. It guarantees O(n log n) time in all cases and is stable, making it ideal for sorting linked lists or data where stability is required. It is not in-place due to the need for auxiliary space.', 'O(n log n)', 'O(n log n)', true, false, '/resources/animations/merge_sort.html', 'testname');
INSERT INTO APP."Algorithms" ("name", "description", "b_time_complexity", "w_time_complexity", "is_stable", "is_in_place", "resource_path", "editor_username") 
	VALUES ('Binary Search', 'Binary Search efficiently finds a target value in a sorted array by repeatedly dividing the search space in half. It runs in O(log n) time in the worst case and is much faster than linear search for large datasets. It requires the input data to be sorted and is commonly used in libraries, databases, and real-time systems.', 'O(1)', 'O(log n)', false, false, '/resources/animations/binary_search.html', 'testname');
